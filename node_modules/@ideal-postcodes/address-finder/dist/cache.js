"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiCache = void 0;
const core_axios_1 = require("@ideal-postcodes/core-axios");
/**
 * @hidden
 */
class ApiCache {
    constructor(client) {
        this.prefix = "!";
        this.client = client;
        this.cache = {};
    }
    key(query) {
        return `${this.prefix}${query.toLowerCase()}`;
    }
    retrieve(query) {
        return this.cache[this.key(query)];
    }
    store(query, data) {
        this.cache[this.key(query)] = data;
        return data;
    }
    clear() {
        this.cache = {};
    }
    /**
     * Retrieve a list of address suggestions given a query
     *
     * Write and read from cache if previously requested
     */
    query(query, options = {}) {
        const cachedValue = this.retrieve(query);
        if (cachedValue)
            return Promise.resolve(cachedValue);
        const p = core_axios_1.autocomplete
            .list(this.client, {
            query: {
                query,
                api_key: this.client.config.api_key,
                ...options,
            },
        })
            .then((response) => {
            const suggestions = response.body.result.hits;
            this.store(query, suggestions);
            return suggestions;
        });
        this.store(query, p);
        return p;
    }
    resolve(suggestion, format) {
        if (format === "usa")
            return this.usaResolve(suggestion);
        return this.gbrResolve(suggestion);
    }
    usaResolve(suggestion) {
        return core_axios_1.autocomplete
            .usa(this.client, suggestion.id, {
            query: { api_key: this.client.config.api_key },
        })
            .then((response) => response.body.result);
    }
    gbrResolve(suggestion) {
        return core_axios_1.autocomplete
            .gbr(this.client, suggestion.id, {
            query: { api_key: this.client.config.api_key },
        })
            .then((response) => response.body.result);
    }
}
exports.ApiCache = ApiCache;
